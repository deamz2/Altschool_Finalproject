# Altschool_Finalproject


The Socks Shop microservices application is to be deployed on Kubernetes as part of this project, with a focus on Infrastructure as Code (IaaC) and contemporary DevOps practices. The goal of using either Ansible or Terraform—I chose to use Terraform—is to create deployment scripts that are understandable and easy to maintain. Important components include the deployment pipeline, logging, and monitoring; Prometheus is used for monitoring, and Alertmanager is used for alerts. Using Let's Encrypt certificates for HTTPS access and other security measures like network security and Ansible Vault for sensitive data, security is given top priority. With this project, we hope to demonstrate efficiency and automation in a Kubernetes environment while achieving a secure and repeatable microservices deployment.

The building of an AWS infrastructure for an EKS (Elastic Kubernetes Service) cluster and related resources is coordinated by this Terraform code. The term "Provider Configuration" in Terraform pertains to specifying the AWS provider information and the required Terraform version, ensuring compatibility and accurate resource provisioning. Transitioning to "Input Variables," these are parameters defining elements such as business division, AWS region, environment, VPC details, and EKS cluster configuration, allowing for flexible customization of the infrastructure. Moving on to "Local Values," this Terraform feature derives specific names, owners, environments, and EKS cluster names, enhancing code readability and maintainability. In the context of Terraform, a "VPC Module" is employed to create a Virtual Private Cloud (VPC) with predetermined configurations, such as public/private subnets, NAT gateways, and DNS settings, promoting modularity and reuse.

The term "Elastic IP for Bastion Host" refers to a feature in Terraform that generates an Elastic IP, providing a secure access point to the bastion host for remote administration, ensuring secure interactions. The combination of "Null Resource and Provisioners" in Terraform allows the execution of remote commands on the bastion host, with information about VPC creation being output, enhancing visibility into the provisioning process. Transitioning to "IAM Role and Policies," this involves specifying the IAM roles necessary for EKS worker nodes, node groups, and the master, ensuring proper authorization and security. The "EKS Cluster Resource" in Terraform establishes an EKS cluster with predetermined configurations, including cluster logging, Kubernetes network configuration, and VPC settings, ensuring a well-defined Kubernetes environment.

In Terraform, "Output Values" provide crucial details about the infrastructure built, such as node group information, VPC ID, CIDR blocks, subnet details, and EKS cluster information, facilitating effective post-deployment management. The term "Infrastructure Details Variables" involves setting values for variables containing specific information about the infrastructure, including the VPC name, CIDR blocks, EKS cluster version and name, and access configurations, streamlining the configuration process and enhancing infrastructure documentation.

The objective of this code is to establish a scalable and maintainable EKS cluster hosting system on AWS, facilitating the deployment of containerized applications through Kubernetes. Within the Kubernetes cluster, the section on ingress rules encompasses two Terraform scripts. First, "Micro.tf" defines a Kubernetes Ingress resource named "sock-shop" in the "sock-shop" namespace, directing traffic from "sock-shop.deamz.org" to the "front-end" service using the Nginx Ingress controller. Additionally, "Prone.tf" configures another Ingress resource called "prometheus-grafana" in the "prometheus" namespace, routing traffic from "grafana.deamz.org" to the "prometheus-grafana" service on port 9090.

In the context of "providertf," this Terraform script configures providers for AWS, Helm, Kubernetes, and kubectl, enabling interaction with the AWS EKS cluster for resource provisioning and management through Terraform and Helm. Moving on to the "Micro-Service" Terraform code, it defines Kubernetes resources for the "Sock Shop" microservices application, deploying various services with unique configurations such as container images, resource constraints, and dependencies. This setup promotes a modular and scalable architecture for microservices deployment on the assumed AWS EKS cluster.

The "Nginx-controller" Terraform script orchestrates the configuration of Route 53 for domain validation, the installation of an NGINX Ingress controller, and the launch of an AWS EKS cluster. It utilizes a structured breakdown, retrieving EKS cluster information, creating namespaces, deploying the NGINX Ingress controller, configuring Route 53 DNS, and handling ACM certificate generation and validation. The script ensures a well-orchestrated setup of essential components.

The "Helm of Prometheus" Terraform script focuses on installing Prometheus on the specified AWS EKS cluster. It establishes a Kubernetes namespace, deploys Prometheus using Helm, and waits for Kubernetes resources to be available. The script relies on Helm, AWS, Kubernetes, and kubectl providers, ensuring seamless integration with the designated EKS cluster in the EU-West-2 region.

The "Installer.sh" script, designed for an Ubuntu server, handles various tasks, including system updates, installations of essential utilities, Helm, Jenkins, AWS CLI, Kubernetes kubectl, and HashiCorp Terraform. It configures keyrings and repositories, sets up Kubernetes kubectl, and installs Jenkins as a system service with adjusted firewall rules for security. The script ensures the necessary tools are in place for subsequent stages.

Finally, the "Jenkinsfile" automates the deployment and destruction of applications on Amazon EKS, deploying Prometheus, the "Sock Shop" microservice, and an Nginx controller with Route 53 on EKS. The pipeline leverages Terraform for infrastructure management, includes setup commands for updating Ubuntu and installing required tools, and ensures security through firewall configurations. User input for environment selection streamlines the management of EKS resources and associated applications on AWS.

Summary
My Project's goal is to use Terraform to deploy the Socks Shop microservices on Kubernetes, with an emphasis on Infrastructure as Code and contemporary DevOps techniques. I use Prometheus for monitoring and Alertmanager for alerts, and we prioritize security with HTTPS and tools like Ansible Vault. The Terraform code prioritizes scalability and clarity while creating an AWS EKS cluster. I also define the NGINX Ingress controller and Kubernetes resources for microservices. The microservices deployment on AWS EKS can be easily replicated due to the project's efficiency and security.



